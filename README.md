# unfriend's html5 boilerplate #

Шаблон вёрстки для проектов. Здесь собраны воедино все техники и инструменты, которые успешно использовались в предыдущих проектах.
Цель - упростить начало вёрстки каждого из проектов и предоставить некоторые готовые решения для типовых задач разработки.

Заготовка расчитана на работу в среде PHP, так как используются функции, возможности, переменные и условные инструкции для этого языка. Конечный "продукт" данного шаблона — набор из header.php, footer.php, подключаемых файлов (изображения, стили, скрипты), плюс все свёрстанные страницы в формате .php.



## Структура папок проекта ##
Первый и второй уровни, упрощённая схема. Более глубокое представление будет далее, по мере описания каждой из сторон проекта.
```
project
|-- assets
|   |-- build
|   |-- scripts
|   |-- sprites
|   |-- styles
|   |-- svg
|   |-- typograph
|-- gulp
|   |-- tasks
|-- media
|   |-- images
|-- include
|   |-- views
|
|-- .gitignore
|-- README.md
|-- package.json
|-- gulpfile.js
|-- robots.txt
|-- humans.txt
|-- functions.php
|-- header.php
|-- footer.php
|-- index.php
|-- pages-list.php
|-- page-styleguide.php
```



## Клонирование репозитория и первоначальная настройка ##
Название проекта необходимо выбирать из ограничений для URL (это строчные латинские символы, можно использовать дефис, цифры, но нельзя использовать нижнее подчёркивание, и т. д.). Допустим, название нового проекта - **blabla**. Тогда:

1. При клонировании репозитория последним аргументом передать название проекта - это создаст на локальной машине папку с необходимым названием.
1. В файле `header.php` заменить переменную `$projectName` на название проекта `blabla`.
1. В файле `/gulp/config.js` заменить `browserSync.params.proxy` на название проекта `blabla`.
1. В логгере [senty.io](https://sentry.io/) добавить новый проект, указав в качестве имени `blabla`. Следуя инструкции, получить публичный ключ и заменить его в файле `/assets/scripts/raven.config.js`.
1. В файле `/assets/SpamProtection.php` найти строчку с `$sentryClient` и заменить в нём приватный ключ от логгера sentry (получить его можно в настройках проекта - https://sentry.io/**blabla**/settings/keys/).
1. Там же - заменить антиспам-соль `$antispamSalt` (только одну) на что-то подходящее, такой же сложности (отлично подходит генератор паролей в keepass).
1. Далее, нужно удалить папку `.git` - это быстрейший способ очистить историю git-коммитов. После удаления, создать новый репозиторий: `git init`.
1. Удалить первоначальный README.md, либо написать в нём что-либо актуальное, о текущем проекте.
1. В качестве названия для удалённого репозитория используется... Да, правильно! Название проекта - **blabla**.
1. Перезапустить OpenServer (на *nix машинах - прописать все необходимые инструкции для нового виртуального хоста). Убедиться, что в браузере сайт открывается по адресу **http://blabla/**.
1. Создать файл `page-main.php`. В нём прописать хедер, футер, и на своё усмотрение добавить произвольный контент (можно взять за основу файл page-styleguide.php). Как для этой, так и для других страниц в дальнейшем, `header.php` надо подключать **строго через require_once**, а `footer.php` - **строго через require**. Это необходимо для того, чтобы правильно формировалась перелинковочная таблица в файле pages-list.php.
1. В файле `index.php` удалить имеющийся код и добавить подключение page-main.php через require_once (в данном случае уже не строго, можно и обычный require). Теперь индексный файл будет открывать главную страницу сайта (первоначальный редирект 307 был сделан, чтобы только показать наличие страницы page-styleguide.php, но не подключать её взамен главной).
1. Находясь на главной странице сайта (http://**blabla**/ или http://**blabla**/page-main.php - теперь это одно и то же), проверить, что перелинковочная таблица формируется верно. Для этого нажать на кнопку в левом нижнем углу экрана.
1. Сделать первый коммит, сделать push, убедиться, что он появился в удалённом репозитории.
1. Вроде бы всё, можно переходить к сборке.



## Сборка проекта ##
Для полноценной работы с данной заготовкой необходимо, чтобы на машине был установлен [Node.js](https://nodejs.org/en/) и сборщик [gulp](http://gulpjs.com/). А также необходимо настроить на машине локальный сервер (вариант для винды - [OpenServer](http://open-server.ru/), вариант для `*nix` - [XAMPP](https://www.apachefriends.org/ru/index.html)).

Установлено и настроено? Отлично, тогда нужно перейти в папку с проектом и в консоли набрать:

1. `npm-check-updates -u`. Данная [утилита](https://www.npmjs.com/package/npm-check-updates) обновит файл package.json, добавив в него последние версии используемых модулей.
1. `npm install`. Начнётся установка необходимых пакетов, которые прописаны в файле `package.json`. На *nix-ах установка происходит быстро, минуту-другую, на винде может занять пол дня _(шутка)_.
1. `gulp`. Соберутся первые `dev` файлы (неминифицированные стили, спрайты и т. п.), запустится watcher, который будет отслеживать изменения в проекте. Запустится [BrowserSync](https://www.browsersync.io/), который будет автоматически перезагружать страницу при изменении файлов проекта.
1. **Profit**. Можно кодить, наконец-то!

Если всё прошло, как надо, то в браузере автоматически откроется http://localhost:3000/.

На локальной машине автоматически активируется режим `dev`. Когда необходимо будет на каком-либо этапе зафиксировать изменения и выложить их на сервер, надо не забыть сделать одну из следующих команд в консоли:

1. `gulp build` - склейка и минификация стилей и скриптов, склейка спрайтов.
1. `gulp build:full` - то же самое, но плюс минификация изображений ("дорогостоящая" операция, плюс иногда бывает необходимо проконтролировать качество минифицированных изображений)


### Дополнительно ###

Описывать здесь целиком то, как работает сборщик, слишком объёмно и на данном этапе - не нужно. Точкой входа всех задач сборщика является файл `gulpfile.js`, лежащий в корне проекта. В папке `/gulp/` хранятся все task'и, котоыре выполняют склейку изображений, конкатенацию скриптов и пр.



## Разделение на dev/prod ##
В проекте присутствует разделение на два вида подключения стилей и скриптов. Пару слов о каждом.

### dev ###
Основной для процесса вёрстки режим. После клонирования себе репозитория, при первоначальной настройке, если всё сделано правильно, данный режим будет включен по умолчанию. Также его можно активировать в любой момент для любой страницы, добавив переменную `?debug=1` к адресу страницы, либо для всего сайта, добавив куку `debug` со значением `1`.

В режиме dev к адресу страницы добавляется строка `[debug]`.

В данном режиме подлючается неминимизированный файл стилей `project.dev.css` вместе с sourcemaps (указание на исходные файлы .styl).
В данном режиме все файлы скриптов подлючаются по отдельности, а для каждого из них выводится в консоль отладочная информация.

В режиме разработки не затрагиваются "боевые" файлы стилей и скриптов, поэтому в нём можно вести разработку на боевом сервере, даже в тот момент, когда сайт запущен и есть вероятность "сломать сайт".

### prod ###
Данный режим автоматически устанавливается, как только проект перенесён на боевой сервер (благодаря комбинации условий с переменной `$projectName`). Но также в него можно войти в любой момент из режима dev, добавив переменную `?debug=0` к адресу страницы.

В данном режиме подключается минимизированная версия стилей `project.min.css` и один минимизированный файл со всеми скриптами `project.min.js`. Всё это идёт уже без отладочной информации. Однако, для правильной и комфортной работы логгера sentry.io, для скриптов создаётся файл sourcemaps, благодаря чему js-ошибки удобно локализировать.



## Стили ##
Для стилей используется препроцессор [Stylus](http://stylus-lang.com/), дополнение к нему [rupture](https://github.com/jenius/rupture) (для адаптива), и постпроцессор [Postcss](https://github.com/postcss/postcss). В процессе сборки проекта автоматически генерируются sourcemaps для стилей, благодаря чему сохраняется указание на исходники при отладке.
Структура папки `/assets/styles/`
```
styles
|-- blocks
|   |-- page-footer.styl
|   |-- page-header.styl
|-- components
|   |-- buttons.styl
|   |-- svg-icon.styl
|   |-- popup.styl
|   |-- ...
|-- mixins
|   |-- aspect-ratio.styl
|   |-- spinner.styl
|   |-- ...
|-- utils
|   |-- normalize.styl
|   |-- reset.styl
|
|-- common.styl
|-- global.styl
|-- layout.styl
|-- print.styl
|-- typography.styl
|-- variables.styl
```

Порядок подключения всех этих файлов определяется в `common.styl`. Из папок `components` и `blocks` все файлы подключаются автоматически, в произвольном порядке. Это соответствует философии подхода независимых блоков и компонентов.
После запуска сборщика проектов, для каждого нового блока достаточно создать свой файл `.styl`, сохранить его в папке `blocks` и результат сразу отобразится на странице.
Сами по себе файлы `.styl` на страницу не подключаются, конечно. Это делает сборщик проектов.

### Соглашения по именованию классов ###
[Первоисточник](https://ru.bem.info/method/naming-convention/#Стиль-Гарри-Робертса)

```
block-name__elem-name--mod-name
```

* Имена записываются в нижнем регистре.
* Для разделения слов в именах БЭМ-сущностей используется дефис `(-)`.
* Имя элемента отделяется от имени блока с помощью двух подчеркиваний `(__)`.
* Модификаторы отделяются с помощью двух дефисов `(--)`.
* Не допускается определять элементы ниже первого уровня относительно блока. Следующая запись — неверная. `block-name__elem-name__elem-child`

### Дополнительно ###
* Крайне не рекомендуется использование атрибута ID для задания стилей элемента.
* Не рекомендуется использование глубокой вложенности селекторов. `.a .b .c > div .e`. Желательно ограничиваться первым (`.a`) и вторым (`.a .b`) уровнем вложенности.
* Желательно придерживаться соответствия между названием файла .styl и класса, который в нём описывается. Например, класс _.main-menu_ и файл _main-menu.styl_.
* Желательно прописывать `&__elem-title`, `&__elem-icon`, `&__elem-date` и т. п. - отдельно, как независимые классы. Следующая запись - неверная:
```
&__elem
    &-title
        ...
    &-icon
        ...
```

### Миксины и полезные функции ###
* **aspect-ratio** - блок с заданным соотношением сторон, которое сохраняется при изменении ширины экрана / блока. Работает через &:before.
* **bullet** - для отображения простого кругуля с заданным цветом и размером.
* **centered** - центрирование элемента по обеим осям. Работает через transform.
* **full-sized** - растягивает элемент до размером родителя. Работает через position: absolute.
* **link-decoration** - замена стандартного свойства text-decoration. Преимущество - возможность менять прозрачность, толщину, при сохранении такого же цвета, как у самого текста. Работает через border-image и linear-gradient. Прописан по-умолчанию для элементов `<a>` без оформления (простые ссылки в тексте страницы).
* **rel-size** - переводит px в rem (или em, при необходимости), относительно базового размера кегля, который дизайнеры отрисовали на макете. Применение: есть макет, на нём базовый кегль 20px, а некий блок имеет ширину 200px. Тогда пишем width rel-size(200px), и получим 10rem, и ширина блока будет динамически изменяться, в зависимости от ширины экрана.
* **spinner** - круговой индикатор загрузки. Необходим, когда нужно дождать чего-то, прежде чем отобразить контент (например, блок с картой, для которого необходимо загрузить библиотеку и т. п.). Работает на &:after и комбинации border'ов.
* **sprite** - для отображения растровых иконок (если необходимо).
* **fz** - преобразует размер кегля из px в em (rem при необходимости), отностельно родительского (или базового, по умолчанию). Например, если у заголовков на макете размер 36px, то следует написать fz(36) или fz(36px) - тогда размер шрифта будет динамически изменяться, в зависимости от размеров экрана.


### Адаптивность, основанная на размере базового кегля ###
[Первоисточник](https://www.npmjs.com/package/postcss-responsive-type)

Для корневого элемента `<html>` задаётся "функция", которая динамически задаёт базовый кегль. Суть в следующем: есть две точки, в которых мы знаем размер базового кегля. Допустим, на 600px шрифт по умолчанию должен быть 16px, а на 1400px он должен быть 20px. Между этими двумя точками строится линейная зависимость, которая даст увеличенный базовый шрифт на экранах > 1400 px, и уменьшенный шрифт на экранах < 600px, а также в каждой из промежуточных точек будет какой-то свой размер шрифта.

Далее, от базового кегля "наследуются" такие величины, как rem и em. Таким образом, работая с данными единицами измерения, мы имеем динамические размеры элементов на странице. Теперь один и тот же блок будет хорошо выглядеть как на макете 1400px (каким его видят дизайнеры), так и на огромном мониторе 1920px (блок увеличится в размерах, а также шрифт станет крупнее, и в целом это будет смотреться лучше, чем если бы размеры блока и размеры шрифта не изменились - тогда они казались бы слишком мелкими).

Данная технология хорошо себя зарекомендовала. Небольшое изменение относительно первоначального варианта: добавилась третья точка, в силу того, что начиная с мелких экранов, зависимость должна быть более пологая (меньше изменяться базовый кегль), нежели для крупных экранов (где необходимо сильнее увеличивать кегль в зависимости от ширины экрана).

```
font-responsive--v2(fz-min, cp-min-font, fz-mid, cp-mid-font, fz-default, cp-default-font)
```



## Скрипты ##
Для подключения и сборки скриптов используется система, которую с некоторыми оговорками можно назвать модульной. Для начала струкрута папки `/assets/scripts/`:
```
scripts
|-- unit-tests
|   |-- chai-2.1.1.min.js
|   |-- mocha-2.1.0.min.css
|   |-- mocha-2.2.1.min.js
|   |-- mocha-clean-0.3.0.js
|-- modules
|   |-- formsValidation.js
|   |-- popups.js
|   |-- windowResize.js
|   |-- windowScroll.js
|   |-- slidersLibrary.js
|   |-- ...
|
|-- jquery-3.0.0.min.js
|-- debug-flag-enabled.js
|-- browser-update.min.js
|-- parsley.min.js
|-- app.js
|-- raven.min.js
|-- raven.config.js
```

"Точкой входа" всех скриптов является файл **app.js**. В нём инициализируется объект `app = {}`, который содержит в себе несколько полезных функций.

Далее, для того, чтобы написать произвольный js-код на странице, достаточно создать новый файл и сохранить его в папке **modules** и обновить страницу. В режиме `dev` подключаются все .js файлы из папки `/assets/scripts/modules/` (в т. ч. из вложенных папок), в произвольном порядке. Ниже будет дано объяснение, почему порядок подключения файлов здесь не имеет значения.

Одна атомарная единица кода ("модуль") создаётся следующим способом:
```
app.createModule("moduleName", ["depModule1", "depModule2", ...], function() {
    console.log("module initialized"); // проверка, добавился ли модуль
    ...
});
```

Первый параметр - название модуля. В дальнейшем к модулю можно будет обратиться через `app.modules.moduleName`.

Второй (опционально) - массив, в котором перечислены названия других модулей, от которых зависит функционал текущего. Зависимости будут подключены до инициализации текущего модуля, и в том порядке, в котором они указаны в массиве. Вот почему нет необходимости задавать порядок на этапе подключения .js файлов. Изначально каждый модуль должен быть самодостаточен, но при этом зависимости всегда можно прописать, если это необходимо.

Третий - функция, которая будет инициализирована после загрузки страницы _(document ready)_.

Собственно, это всё сделано для того, чтобы уйти от одного файла main.js, в котором со временем образуется длинная простыня нечитабельного кода. Модули должны выполнять конкретные действия. Например, раскрывающиеся блоки - один модуль, прилипшая fixed шапка страницы - другой модуль, и т. д. На одной странице вполне нормально уживаются сразу несколько модулей.

Для заготовки уже написаны некоторые модули, которые используются практически в любом проекте. Некоторые из них:

* **popups** - отвечает за открытие/закрытие модальных окон.
* **formsValidation** - проверка заполнения форм.
* **windowResize** - диспетчер события изменения размеров окна браузера.
* **pageLoad** - диспетчер события полной загрузки страницы (отличается от document ready).
* **windowScroll** - диспетчер события прокрутки страницы.
* **slidersLibrary** - подгружает клёвую библиотеку для листалок на сайте.
* **linksWithHash** - определяет, есть ли на странице элементы `<a>`, у которых не проставлена ссылка (вместо неё - решётка). Полезно на продакте.
* **formsAntispam** - клиентская часть антиспам-проверки для форм. Добавляет одно скрытое поле через фиксированное время, а второе - только после определённого действия пользователя.
* **browserUpdate** - подгружает скрипт с сайта [browser-update.org](http://browser-update.org/), который определяет, устарел браузер или нет, и предлагает обновиться.
* **mobMenu** - для работы мобильного меню (бургера).
* **responsiveTables** - в шаблоне реализован механизм преобразования рядом таблицы в отдельные блоки. Для полноценной работы необходимо проставить определённые data-атрибуты в таблице, и проще всего это сделать скриптами.

В режиме `prod` точка входа и все отдельные модули склеиваются в один минифицированный файл.

### Лирика ###
Почему не используются [ES6-модули](http://www.2ality.com/2014/09/es6-modules-final.html) или другие модульные системы? По-хорошему, модули нужны для сложных веб-приложений, где у тебя могут быть сотни файлов и несколько мегабайт итогового кода. Для простых сайтиков необходимо было лишь разбиение простыни из main.js на более мелкие куски кода. Так и была придумана система, описанная в данном шаблоне.

Для небольших проектов полноценная модульная система может быть чересчур громоздкой. Для модулей ES6 пока ещё стоит вопрос поддержки в браузерах. Да, это всё решается с помощью доп. полифиллов и пр. Если хочется использовать "правильные" модули, будь то ES6, Amd или CommonJS, - пожалуйста.

### CoffeeScript ###
Для скриптов можно использовать язык [Coffeescript](http://coffeescript.org/). В данной заготовке он используется исключительно как "синтаксический сахар". В целом сборка проекта работает уже с файлами .js, которые из .coffee компилируются сразу при сохранении благодаря плагину [better-coffeescript](https://github.com/aponxi/sublime-better-coffeescript) для редактора Sublime Text.

### Дополнительно ###
* Для js-кода желательно придерживаться camelCase именования для переменных и функций. Также файлы скриптов желательно сохранять под теми же именами, что и названия соответствующих модулей (например: app.modules.pageLoad и pageLoad.js).
* В папке `/assets/scripts/modules/` есть папка `/cs/` - в ней хранятся модули, написанные на CoffeeScript. В этой папке **не надо** править файлы .js. Править только .coffee. Иначе придёт человек, который пишет на Cofee, изменит .coffee и перезапишет твои изменения. Поэтому, либо надо либо изучить этот синтаксический сахар (несложный), либо перенести .js на уровень выше, в корень папки /modules/, и там уже править (соответственно, удалить файл .coffee из папки /cs/).
* В сборщике проектов предусмотрено удаление кода, который следует за константой DEBUG. В режиме `dev`, с помощью этой константы удобно писать отладочный код. Например, строка `DEBUG && console.log('бла-бла-бла.. длинное описание того, что там в коде происходит')` будет **целиком** удалена из минифицированного файла. И это справедливо не только для вывода в консоль, но и для любого кода, написанного после DEBUG. Например, если писать юнит-тесты, то их можно писать там же, в коде для каждого модуля, предварительно включив их в блок `if (DEBUG) {...}`. Данная константа позволяет на выходе получить ощутимую разницу в размере файла, сохранив при этом _всю_ отладочную информацию в исходных файлах.

### unit-тестирование ###
Если имеется представление, что такое [юнит-тестирование](https://www.smashingmagazine.com/2012/06/introduction-to-javascript-unit-testing/), то у меня хорошая новость: здесь можно писать юнит-тесты. В проекте в режиме `dev` подключается библиотека [Mocha](https://mochajs.org/) (_смешное название_). Синтаксис - [Expect](http://chaijs.com/guide/styles/#expect). По умолчанию инит-тестирование отлючено, включить можно в самом начале файла `header.php`, либо добавив get-папаметр ?unit=1.




## Растровые иконки ##
Мелкие картинки автоматически склеиваются в спрайты. Их необходимо сохранять в папке `/assets/sprites/common/`. При необходимости (которая возникает редко) можно выделять отдельную группу иконок в отдельный спрайт (например, отдельная страница с очень большим кол-вом мелких изображений, но причём на большинстве других страниц эти изображения ну никак не нужны и только зря будут грузиться). В таком случае нужно сохранять не в `common`, а в папку с другим названием (например, `/assets/sprites/big-teasers/`).

Для того, чтобы использовать изображение `book.png` из спрайта, необходимо в стилях прописать:
```
.icon
    sprite "book"
```
Элементу автоматически присвоются необходимые _width, height, background-position_ и пр.

### Дополнительно ###
Иногда необходимо "по-быстрому" запилить какую-нибудь иконку для страницы. Мелкие изображения можно грузить в [base64](https://ru.wikipedia.org/wiki/Data:_URL), причём переводя их в такой формат "на лету", с помощью препроцессора Stylus, который используется для данной заготовки. Достаточно заменить `url` на `inline-url` в стилях. Пример:
```
.some-icon
    width 20px
    height 20px
    background transparent inline-url('/media/images/some-icon.png') 0 0 no-repeat
```
Однако, злоупотреблять этим не стоит, иначе итоговый .css файл раздуется до неприличных размеров.

### Лирика ###
В последних проектах растровые иконки не используются. Да здравствует вектор! Но на всякий случай возможность склейки обычных растровых спрайтов оставлена.


## SVG ##
Для векторных иконок используется система спрайтов, основанная на элементе `<use>` ([почитать](https://una.im/svg-icons/)). Исходные иконки помещаются в папку /assets/svg/sprite/, а подключения её на странице, используется следующий код (пример для файла с названием arrow-left.svg):
```
<svg class="svg-icon">
    <use xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="#svg-arrow-left"></use>
</svg>
```
Дополнительно примеры иконок можно посмотреть в файле page-styleguide.php.


## Автоматическая проверка кода ##
В проекте используются линтеры: [stylint](https://www.npmjs.com/package/stylint) для файлов .styl, и [eslint](http://eslint.org/) для файлов .js. Правил довольно много, но зато на выходе мы получаем код, который у разных разработчиков имеет хотя бы общий вид. Без линтеров будет полный хаос.


## Что можно удалять и что нельзя ##

По вёрстке:

* Нельзя удалять .l-wrapper, .l-header, .l-content и .l-footer - это конструкция, которая не влияет на внешний вид данных блоков, но отвечает за их расположение, что шапка - всегда сверху, подвал - прибит к низу страницы, а контент - расширяется на всё оставшееся пространство. Также .l-wrapper необходим для правильной работы всплывашек (чтобы при открытии всплывашки основной сайт не пролистывался вместе с ней).
* Не рекомендуется удалять .l-container. Он отвечает за отступы от краёв экрана, чтобы контент (в т. ч. на странице page-styleguide.php) не прилипал к границам и выглядел сносно. Для задания отступов используется переменная site-paddings.
* Из того, что можно "безболезненно" удалять: части, связанные с $rawContainer (это сделано для страниц, где нужно изначально дать контент в край экрана), с работой типографа (он хорош, но бывают сложности в его использовании), можно удалять .page-header, .page-footer и то, что в них (но при этом всё= должны остаться .l-header и .l-footer). Можно удалять код, который идёт в режиме dev (т. е. после инструкций вида if ($debug) { ... }) - хотя он написан для удобства навигации по вёрстке, для самопроверки и пр.
* Нельзя удалять настройки проекта в верхней части header.php - они нужны для того, чтобы в любой момент можно было перейти в режим dev или prod, и не только.
* Не стоит удалять элементы в нижней части footer.php - это для разделения на dev\prod, а также для связи php и js (да, и такое пригождается).
* Можно удалить всё, что связано с мобильным меню, если текущий его вид **полностью** не удовлетворяет требованиям дизайна. Если общее поведение бургера устраивает, то лучше оставить текущую вёртку и скрипт (модуль mobMenu), и только стилизовать\доработать.
* В header.php есть код, который выводит всплывашку с перелинковкой всех свёрстанных страниц. Это удобно, т. к. позволяет быстро перейти к любой странице. Удалять не рекомендуется, но в целом на функционал это не влияет.


По стилям:

* Можно удалить всё, что на начало вёрстки есть в папке blocks - эти стили для примера, чтобы страница хоть как-то выглядела.
* А вот удалять папки components, utils, и др., а также многое из того, что подключается в common.styl - лучше не стоит.
* Всё, что есть в файле variables.styl - удалять не стоит. Нужно имеющиеся переменные подстраивать под себя, и/или добавлять новые.


По скриптам:

* Можно удалить папку unit-test и всё, что связано с юнит-тестами. Хотя они подключаются "по требованию" и никак не влияют на вёрстку.
* Можно удалять те модули в папке /assets/scripts/modules/, которые тебе **точно** не понадобятся. Например, если в проекте нет ни одного слайдера, то можно удалить модуль slidersLibrary. Если нет ни одной всплывашки, то можно удалить модуль popups. А можно удалить все и написать свои, так, как нужно тебе.
* В файле app.js есть код, который выводит время инициализации всех модулей. Это сделано для того, чтобы можно было 1) видеть, какие именно модули подключились на текущей странице, 2) видеть время инициализации, чтобы при обнаружении "тяжелого" модуля найти причину и устранить.


По остальному:

* Папку /gulp/ удалять нельзя. В папке /include/ хранятся подключаемые куски вёрстки (как использовать - см. page-styleguide.php). В папке /media/ можно и нужно хранить изображения, а также можно добавлять туда документы (создать папку /media/docs/), видео (создать папку /media/video/) и пр.


## Страница с типовыми элементами ##
Страница page-styleguide.php - это [лакмусовая бумажка](https://ru.wiktionary.org/wiki/лакмусовая_бумажка), индикатор качества вёрстки. Смысл данной страницы следующий. Есть шапка, подвал, и какой-то контент между ними. И для каждого проекта, каким бы особенным он ни был, необходимо предусмотреть такую вёрстку, при которой **произвольный неоформленный специально** контент будет выглядеть **сносно**. Не должно быть такого, что такая страница будет выглядеть развалившейся, пока не добавишь какой-то там специальный класс (об этом никто, кроме верстальщика, не знает).

Пример из жизни. Мы сверстали сайт, натянули его на Битрикс, сдали заказчику. Заказчик хочет создать новую страницу. Он нажимает кнопку "Создать страницу", указывает ей заголовок, добавляет на неё один абзац текста и небольшой список. Сохраняет, и видит... О ужас! Страница выглядит, как говно! Текст прилип к краям экрана, а у маркированного списка отсутствуют маркеры. Говорить, что заказчик тупой и должен быть в курсе, что странице надо задать какой-то там класс или какую-то переменную, и только тогда страница начнёт выглядеть нормально - это **принципиально неверная позиция**. И не потому, что заказчик всегда прав. А потому, что вёрстка должна быть "нормализированной", должны присутствовать стили для большинства стандартных элементов (списки разных видов, таблицы, кнопки, формы и пр.), а также не должно быть привязки к конкретному проекту (типа раз у нас одностраничник, то и нафиг нам типовые элементы - нет! это тоже неправильная позиция).

Внешний вид страницы page-styleguide.php изменяется по мере вёрстки. Но всегда она должна выглядеть **сносно**.


## Стиль кода, принятый для данной заготовки ##

### Общее ###

* Кодировка по-умолчанию для всех файлов: utf-8 (без BOM, почему - ответ [здесь](https://toster.ru/q/303886)).
* Для отступов используются пробелы (а не табы).
* Величина отступа - 4 пробела.
* Формат окончания строки (line endings) - CRLF или LF, в зависимости от системы. На Win - CRLF (+ настроить git config --global core.autocrlf true). На Unix - LF (+ настроить git config --global core.autocrlf input).
* Отступы должны быть расставлены верно. Благодаря этому код должен правильно сворачиваться в редакторе.
* В коде по мере необходимости использовать комментарии вида: TODO: Нужно что-то сделать! NOTE: Мега-важная заметка. FIXME: Всё сломалось, нужно исправить!


### git ###

Используем специальные флаги для команд git:
* git pull --rebase origin master — для того, чтобы не создавались локальные merge-коммиты (подробное описание проблемы - [здесь](https://habrahabr.ru/post/161009/))
* git merge --no-ff branchname — для того, чтобы не засорять историю коммитов (подробное описание проблемы - [здесь](http://stackoverflow.com/questions/9069061/what-is-the-difference-between-git-merge-and-git-merge-no-ff))
* git merge --no-ff --no-commit branchname && git commit -m "your message" — то же самое, но с собственным коммит-собщением (иначе будет автоматическое)


### CSS ###

* Кавычки - двойные.
* Для именований CSS-классов используется [БЭМ-нотация](https://ru.bem.info/methodology/naming-convention/).


### JS ###

* Кавычки - двойные.
* Именование переменных в JS - camelCase.
* Для блоков if...else всегда используются фигурные скобки {...}. В одну строку не пишем.


### HTML ###

* Кавычки у атрибутов - двойные.
* Предпочтение PHP-комментариям (`<? // … ?>`) перед HTML комментариями (`<!-- … -->`).
* Не рекомендуется разбивать HTML-тег на несколько строк, независимо от того, сколько в нём атрибутов и насколько длинной оказывается из-за этого строка (это для того, чтобы можно было корректно работать с мультивыделением по строкам).


## Прочее ##

Напоследок, несколько пожеланий, за которые тебе +100 к карме:

* Каждую страницу вёртски желательно именовать **page-[pagename].php** и сохранять в корневой папке проекта. Например: page-main.php, page-about.php, page-contacts.php. Для режима `dev` файлы с таким именованием собираются в одну общую таблицу, которая формируется в файле `pages-list.php` и которая подключается в `header.php` и в `page-styleguide.php`. В любой момент в режиме `dev` можно нажать на fixed кнопочку в левом нижнем углу экрана и увидеть список свёрстанных страниц.
* Для удобства навигации все свёрстанные страницы должны быть перелинкованы.


-----


**Всё, вперёд, к вершинам славы!**

**Если всё сделаем правильно, то дизайнеры, программисты и даже клиенты будут тебя обожать! ;)**